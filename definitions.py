# definitions.py
from config import *
from enum import Enum, auto
from typing import Dict, Any, List, Optional
import time

# --- Enums ---

class CognitivePrinciple(Enum):
    """Core principles that guide behavior - not hardcoded actions"""
    HOMEOSTASIS = auto()         # Maintain internal equilibrium
    PREDICTION = auto()          # Minimize prediction error
    INFORMATION_GAIN = auto()    # Maximize information
    COMPLEXITY_BOUND = auto()    # Avoid runaway complexity
    COHERENCE = auto()           # Internal consistency
    EFFICIENCY = auto()          # Resource optimization
    GROWTH = auto()              # Capability expansion
    PRESERVATION = auto()        # Self-preservation
    EXPLORATION = auto()         # Novelty seeking
    EXPLOITATION = auto()        # Leverage known strategies

class ActionType(Enum):
    """Flexible action types - can be extended dynamically."""
    # Core actions
    PROCESS_INPUT = auto()
    READ_FILE = auto()
    RESEARCH = auto()
    SELF_MODIFY = auto()
    EXPLORE = auto()
    SIMULATE = auto()
    REFLECT = auto()
    LEARN = auto()
    SPEAK = auto()
    
    # Meta-cognitive actions
    HYPOTHESIZE = auto()
    EXPERIMENT = auto()
    CONSOLIDATE = auto()
    OPTIMIZE = auto()
    MONITOR = auto()

    # Architectural actions (new)
    BUILD_SKILL = auto()         # Construct new capability
    COMPOSE_SKILLS = auto()      # Combine existing skills
    MODIFY_ARCHITECTURE = auto() # Change cognitive structure
    HEAL = auto()                # Self-repair
    CHECKPOINT = auto()          # Save cognitive state
    ROLLBACK = auto()            # Restore previous state

    # Emergent actions (new)
    ABSTRACT = auto()            # Form abstractions
    ANALOGIZE = auto()           # Find analogies
    SYNTHESIZE = auto()          # Combine concepts
    PRUNE = auto()               # Remove unused structures
    SPECIALIZE = auto()          # Develop expertise
    GENERALIZE = auto()  
    
    RECURSIVE_THINK = auto()   # Self-feeding thought loop
    HYPER_PLASTICITY = auto()  # Trigger temporary rapid learning        # Broaden applicability
    GROUND_CONCEPT = auto()    # Verify concept against sensors
    MOTOR_COMMAND = auto()     # Physical movement
    EXECUTE_SKILL = auto()
    SYS_MOD = auto()


class FailureType(Enum):
    LACK_OF_KNOWLEDGE = auto()
    EXECUTION_ERROR = auto()
    TIMEOUT = auto()
    CONFLICT = auto()
    OVERLOAD = auto()
    NETWORK_ERROR = auto()
    INVALID_INPUT = auto()
    RESOURCE_EXHAUSTION = auto()
    ARCHITECTURAL_INSTABILITY = auto()
    SKILL_INCOMPATIBILITY = auto()
    UNKNOWN = auto()

class HealthMetric(Enum):
    """Health indicators for cognitive functioning"""
    COHERENCE = auto()        # Internal consistency
    RESPONSIVENESS = auto()   # Reaction time
    ADAPTABILITY = auto()     # Learning rate
    STABILITY = auto()        # Resistance to perturbation
    EFFICIENCY = auto()       # Resource usage
    ROBUSTNESS = auto()       # Error recovery

class SemanticRole(Enum):
    """Universal semantic roles shared by all human languages."""
    AGENT = auto()       # The doer/causer (e.g., "THE CAT" eats)
    PREDICATE = auto()   # The action/state (e.g., the cat "EATS")
    PATIENT = auto()     # The undergoer/receiver (e.g., eats "THE MOUSE")
    MODIFIER = auto()    # Adjectives/Adverbs (e.g., "HUNGRY" cat)
    LOCATION = auto()    # Spatial context (e.g., "IN THE KITCHEN")
    TIME = auto()        # Temporal context (e.g., "YESTERDAY")
    DET = auto()         # Determiners (e.g., "THE", "A")
    UNKNOWN = auto()

# --- Data Classes ---

@dataclass
class Action:
    action_type: ActionType
    payload: any = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: float = field(default_factory=time.time)
    emergent: bool = False  # True if generated by system itself
    
    def __str__(self) -> str:
        return f"{self.action_type.name}: {str(self.payload)[:50]}"

    def age(self) -> float:
        return time.time() - self.created_at

    def to_dict(self) -> Dict[str, Any]:
        return {
            'type': self.action_type.name,
            'payload': self.payload,
            'metadata': self.metadata,
            'created_at': self.created_at,
            'emergent': self.emergent
        }

@dataclass
class Principle:
    """A cognitive principle with dynamic weight"""
    type: CognitivePrinciple
    weight: float = 1.0
    satisfaction: float = 0.5  # How well satisfied (0-1)
    violations: int = 0

    def update_satisfaction(self, value: float):
        """Exponential moving average"""
        alpha = 0.2
        self.satisfaction = alpha * value + (1 - alpha) * self.satisfaction

@dataclass
class Skill:
    """
    A learned capability - can be composed and modified.
    Skills are programs the agent writes for itself.
    """
    name: str
    description: str
    preconditions: List[str]  # What must be true to use this skill
    effects: List[str]        # What changes after using this skill
    code: str                 # Python code (as string, for safety)
    success_rate: float = 0.5
    uses: int = 0
    created_at: float = field(default_factory=time.time)
    parent_skills: List[str] = field(default_factory=list)  # Composition

    def can_execute(self, context: Dict[str, Any]) -> bool:
        """Check if preconditions are met"""
        # Simple check: all precondition strings should be in context keys
        return all(pre in context for pre in self.preconditions)

    def update_success(self, success: bool):
        """Update success rate"""
        alpha = 0.2
        self.uses += 1
        new_value = 1.0 if success else 0.0
        self.success_rate = alpha * new_value + (1 - alpha) * self.success_rate

@dataclass
class HealthStatus:
    """Current health state"""
    metric: HealthMetric
    value: float  # 0-1, higher is better
    trend: float  # -1 to 1, negative is declining
    critical: bool = False

    def is_healthy(self) -> bool:
        return self.value > 0.3 and not self.critical

@dataclass
class Abstraction:
    """
    A learned abstraction - pattern extracted from experience.
    The agent forms its own concepts.
    """
    name: str
    pattern: Dict[str, Any]  # The pattern being abstracted
    instances: List[Any]     # Concrete instances
    generality: float        # How general vs specific (0-1)
    created_at: float = field(default_factory=time.time)

    def matches(self, instance: Any, threshold: float = 0.7) -> bool:
        """Check if instance matches this abstraction"""
        if isinstance(self.pattern, dict) and isinstance(instance, dict):
            matching_keys = set(self.pattern.keys()) & set(instance.keys())
            if not matching_keys:
                return False
            
            match_score = len(matching_keys) / max(len(self.pattern), len(instance))
            return match_score >= threshold
        
        return False

@dataclass
class Episode:
    timestamp: float
    action: Action
    context: Dict[str, Any]
    outcome: bool
    failure_type: Optional[FailureType] = None
    latency: float = 0.0
    emotional_valence: float = 0.0
    abstraction_tags: List[str] = field(default_factory=list)

    def age(self) -> float:
        return time.time() - self.timestamp

class GoalStatus(Enum):
    PENDING = auto()
    ACTIVE = auto()
    COMPLETED = auto()
    FAILED = auto()

@dataclass(order=False)

class Goal:
    priority: float
    action: Action = field(compare=False)
    status: GoalStatus = field(default=GoalStatus.PENDING, compare=False)
    attempts: int = field(default=0, compare=False)
    context: Dict[str, Any] = field(default_factory=dict, compare=False)

    def __lt__(self, other):
        return self.priority > other.priority

class MetaEvent:
    SUCCESS = "SUCCESS"
    FAILURE = "FAILURE"
    STALL = "STALL"
    OVERLOAD = "OVERLOAD"
    BREAKTHROUGH = "BREAKTHROUGH"

# Update Goal default status to use Enum
Goal.status = GoalStatus.PENDING